import consola from 'consola'

export function generateServerAPIMethods (methods) {
  const body = generateServerAPIMethodsBody(methods)
  return (
    '// This file is autogenerated by server/main.js\n' +
    `export default ({ handlers, translateRequest, translateRequestWithPayload }) => ({\n${body}})`
  )
}

export function generateClientAPIMethods (methods) {
  const body = generateClientAPIMethodsBody(methods)
  return (
    '// This file is autogenerated by server/main.js\n' +
    `export default client => ({\n${body}})`
  )
}

const ssrAPITimeout = 10000

class SSRAPIRequestTimeoutError extends Error {
  constructor (req) {
    super(`SSR API request did not complete in time: ${JSON.stringify(req, null, 2)}`)
    this.name = 'SSRAPIRequestTimeoutError'
    this.req = req
  }
}

function logError (err) {
  if (process.dev) {
    consola.error(err)
  } else if (process.sentry) {
    process.sentry.captureException(err)
  }
}

function isObject (val) {
  return val !== null && typeof val === 'object' && !Array.isArray(val)
}

function startTimeout (req, resolve) {
  return setTimeout(() => {
    logError(new SSRAPIRequestTimeoutError(req))
    resolve({})
  }, ssrAPITimeout)
}

export function translateRequest (handler, params, url, options = {}) {
  consola.info('SSR API request:', url, params)
  return new Promise((resolve, reject) => {
    try {
      const cancelTimeout = startTimeout({ params, url }, resolve)
      handler(
        {
          url,
          params,
          query: options.params,
          headers: options.headers,
        },
        {
          send: (data) => {
            clearTimeout(cancelTimeout)
            resolve({ data })
          },
        },
      )
    } catch (err) {
      logError(err)
      reject(err)
    }
  })
}

export function translateRequestWithPayload (handler, params, url, data, options = {}) {
  consola.info('SSR API request w/ payload:', url, params, data)
  return new Promise((resolve, reject) => {
    try {
      const cancelTimeout = startTimeout({ params, url, data }, resolve)
      handler(
        {
          url,
          params,
          body: data,
          query: options.params,
          headers: options.headers,
        },
        {
          send: (data) => {
            clearTimeout(cancelTimeout)
            resolve({ data })
          },
        },
      )
    } catch (err) {
      logError(err)
      reject(err)
    }
  })
}

function generateServerAPIMethodsBody (methods, loadedMethods = '', path = null, level = 1) {
  const indent = new Array(level * 2).fill(' ').join('')
  for (const prop of Object.keys(methods)) {
    const val = methods[prop]
    if (isObject(val)) {
      loadedMethods += `${indent}${prop}: {\n`
      loadedMethods = generateServerAPIMethodsBody(val, loadedMethods, path ? `${path}.${prop}` : prop, level + 1)
      loadedMethods += `${indent}},\n`
    } else if (Array.isArray(val)) {
      const args = ['options = {}']
      const params = []
      let url = val[1].replace(/:([\w\d_$]+)/g, (_, param) => {
        params.push(param)
        return `\${${param}}`
      })
      if (url.includes('${')) {
        url = `\`${url}\``
      } else {
        url = `'${url}'`
      }
      const method = val[0].toLowerCase()
      if (params.length) {
        args.splice(0, 0, ...params)
      }
      const methodPath = path ? `${path}.${prop}` : prop
      if (['post', 'put'].includes(method)) {
        args.splice(-1, 0, 'data')
        loadedMethods += (
          `${indent}${prop} (${args.join(', ')}) {\n` +
          `${indent}  return translateRequestWithPayload(handlers.${methodPath}, { ${params.join(', ')} }, ${url}, data, options)\n` +
          `${indent}},\n`
        )
      } else {
        loadedMethods += (
          `${indent}${prop} (${args.join(', ')}) {\n` +
          `${indent}  return translateRequest(handlers.${methodPath}, { ${params.join(', ')} }, ${url}, options)\n` +
          `${indent}},\n`
        )
      }
    }
  }
  return loadedMethods
}

function generateClientAPIMethodsBody (methods, loadedMethods = '', path = null, level = 1) {
  const indent = new Array(level * 2).fill(' ').join('')
  for (const prop of Object.keys(methods)) {
    const val = methods[prop]
    if (isObject(val)) {
      loadedMethods += `${indent}${prop}: {\n`
      loadedMethods = generateClientAPIMethodsBody(val, loadedMethods, path ? `${path}.${prop}` : prop, level + 1)
      loadedMethods += `${indent}},\n`
    } else if (Array.isArray(val)) {
      const args = ['options = {}']
      const params = []
      let url = val[1].replace(/:([\w\d_$]+)/g, (_, param) => {
        params.push(param)
        return `\${${param}}`
      })
      if (url.includes('${')) {
        url = `\`${url}\``
      } else {
        url = `'${url}'`
      }
      const method = val[0].toLowerCase()
      if (params.length) {
        args.splice(0, 0, ...params)
      }
      if (['post', 'put'].includes(method)) {
        args.splice(-1, 0, 'data')
        loadedMethods += (
          `${indent}${prop} (${args.join(', ')}) {\n` +
          `${indent}  return client.${method}(${url}, data, options)\n` +
          `${indent}},\n`
        )
      } else {
        loadedMethods += (
          `${indent}${prop} (${args.join(', ')}) {\n` +
          `${indent}  return client.${method}(${url}, options)\n` +
          `${indent}},\n`
        )
      }
    }
  }
  return loadedMethods
}
